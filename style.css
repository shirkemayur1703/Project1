Ahh okay ‚Äî you specifically want to see HOW to do this with an HOC, not just hooks.
Got it. Let me give you the working HOC pattern for your exact use case.


---

‚úÖ Goal

You have:

One Form component

Two flows (CaseA + CaseB)

Some props common

Some props different

Some functions same name but different logic

Common and case-specific state

And you want all this using an HOC (Higher-Order Component).


Yes ‚Äî this is possible.


---

üß© Concept: withFormLogic(flag)

The HOC:

Receives a flag "A" or "B"

Creates the common state

Loads CaseA or CaseB utilities & state

Merges everything into one combined props object

Wraps the Form component



---

üéØ WORKING SOLUTION (HOC + Hooks + Shared State in Parent)


---

üìå 1. HOC: withFormLogic.js

import useCaseALogic from "../hooks/useCaseALogic";
import useCaseBLogic from "../hooks/useCaseBLogic";

export default function withFormLogic(FormComponent) {
  return function WrappedForm({ flow }) {
    // COMMON STATE inside HOC
    const [username, setUsername] = React.useState("");
    const [error, setError] = React.useState(null);
    const [loading, setLoading] = React.useState(false);

    const validateUsername = (name) => name.length >= 3;

    const common = {
      username,
      setUsername,
      error,
      setError,
      loading,
      setLoading,
      validateUsername,
    };

    // CASE-SPECIFIC LOGIC
    const caseA = flow === "A" ? useCaseALogic(common) : null;
    const caseB = flow === "B" ? useCaseBLogic(common) : null;

    // MERGED FINAL PROPS
    const mergedProps = {
      ...common,
      ...(flow === "A" ? caseA : caseB),
      flow,
    };

    return <FormComponent {...mergedProps} />;
  };
}


---

üìå 2. CaseA hook

import { useState, useCallback } from "react";

export default function useCaseALogic(common) {
  const [age, setAge] = useState("");

  const submit = useCallback(() => {
    if (!common.validateUsername(common.username)) {
      common.setError("Invalid username for A");
      return;
    }
    if (Number(age) < 18) {
      common.setError("You must be 18+");
      return;
    }
    alert("Case A Submitted!");
  }, [age, common]);

  return { age, setAge, submit };
}


---

üìå 3. CaseB hook

import { useState, useCallback } from "react";

export default function useCaseBLogic(common) {
  const [email, setEmail] = useState("");

  const submit = useCallback(() => {
    if (!common.validateUsername(common.username)) {
      common.setError("Invalid username for B");
      return;
    }
    if (!email.includes("@")) {
      common.setError("Invalid email");
      return;
    }
    alert("Case B Submitted!");
  }, [email, common]);

  return { email, setEmail, submit };
}


---

üìå 4. Form component

export default function Form(props) {
  return (
    <div style={{ padding: 20 }}>
      <h3>Flow: {props.flow}</h3>

      <div>
        <label>Username:</label>
        <input
          value={props.username}
          onChange={(e) => props.setUsername(e.target.value)}
        />
      </div>

      {props.flow === "A" && (
        <div>
          <label>Age:</label>
          <input
            value={props.age}
            onChange={(e) => props.setAge(e.target.value)}
          />
        </div>
      )}

      {props.flow === "B" && (
        <div>
          <label>Email:</label>
          <input
            value={props.email}
            onChange={(e) => props.setEmail(e.target.value)}
          />
        </div>
      )}

      {props.error && <p style={{ color: "red" }}>{props.error}</p>}

      <button onClick={props.submit}>Submit</button>
    </div>
  );
}


---

üìå 5. Use HOC in Parent

import withFormLogic from "./hoc/withFormLogic";
import Form from "./components/Form";

const EnhancedForm = withFormLogic(Form);

export default function App() {
  const [flow, setFlow] = React.useState("A");

  return (
    <div style={{ padding: 20 }}>
      <button onClick={() => setFlow("A")}>Case A</button>
      <button onClick={() => setFlow("B")}>Case B</button>

      <EnhancedForm flow={flow} />
    </div>
  );
}


---

üéâ RESULT

‚≠ê You have ONE Form

‚≠ê ONE HOC that generates all props

‚≠ê Clean separation of:

common state

case-specific state

case-specific functions

shared functions

dynamic props

different flows


‚≠ê And yes, the same function name submit can be reused for both flows ‚Äî because the HOC maps the correct version.


---

Want EXTREME CLEAN version?

I can also give you:

HOC + TypeScript version

HOC + Context version

HOC + Zustand store version

HOC auto-injecting fields instead of manual checks


Just tell me!
